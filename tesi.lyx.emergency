#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vfill
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size largest
UNIVERSITÀ DEGLI STUDI DI TRENTO
\end_layout

\begin_layout Standard

\size larger
Dipartimento di Ingegneria e Scienza dell’Informazione
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{70pt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/logo_unitn.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{70pt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size large
CORSO DI LAUREA TRIENNALE IN INFORMATICA
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{30pt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Elaborato Finale
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{30pt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size largest
DATABASE TEMPORALI
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{50pt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size large
Relatore: Prof.
 Gabriel Kuper 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hspace{30pt}
\end_layout

\end_inset

 Laureando: Andrea Gottardi
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{20pt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Anno accademico 2013/2014
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout


\backslash
date{}
\end_layout

\end_inset


\end_layout

\begin_layout Title
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\align right

\shape italic
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace*{
\backslash
fill}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align right

\shape italic
Any sufficiently advanced technology is equivalent to magic.
\end_layout

\begin_layout Standard
\align right

\shape italic
–Sir Arthur C.
 Clarke
\end_layout

\begin_layout Standard
\align right
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace*{
\backslash
fill}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
mbox{} 
\backslash
thispagestyle{empty} 
\backslash
newpage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tableofcontents
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part*
Ringraziamenti
\end_layout

\begin_layout Standard
Prima di cominciare, voglio ringraziare alcune persone che hanno avuto un
 ruolo importante in tutti questi anni di studio.
 La lista non è sicuramente esaustiva, ma anche a chi non è elencato va
 il mio più sincero ringraziamento.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Prima di tutto, voglio ringraziare la mia famiglia, che mi ha sostenuto,
 incoraggiato e aiutato in tutti questi anni di studio;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Grazie ai miei "colleghi" e compagni di corso Alessandro, Antonio, Mattia
 e Stefano, per aver trascorso insieme la preparazione di questi ultimi
 esami, dove casa mia é diventata il quartier generale dello studio (senza
 disdegnare calcio balilla e console per videogiochi) ;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Infine, grazie anche alla mia fidanzata Giulia, per aver ascoltato le mie
 paranoie alla fine di ogni esame, dicendomi che sarebbe andato bene (e
 puntualmente ci ha azzeccato ogni volta, ma non ho mai voluto ammettere
 avesse ragione)
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Abstract
La vita dell'uomo, fin dalla sua prima comparsa sulla Terra, è sempre stata
 scandita dal tempo: all'inizio le unità di misura del tempo erano molto
 approssimate e variabili, basti pensare al concetto di giorno e notte,
 oppure di alba e tramonto, ma ciò era più che sufficiente per organizzare
 e gestire al meglio il lavoro, nei campi oppure a caccia.
 Con il passare del tempo, e con l'invenzione degli orologi, il tempo ha
 assunto una connotazione sempre più importante: se prima un'approssimazione
 anche di diverse ore non era particolarmente influente, questa approssimazione
 è diventata sempre meno estesa, e di conseguenza il calcolo del tempo è
 diventto più accurato, passando dai minuti, ai secondi, ai millesimi di
 secondo, fino ad arrivare ai moderni orologi atomici al cesio, che è stato
 calcolato possano sbagliare di un secondo ogni 100 milioni di anni.
 Esiste anche una nuova concezione di orologi atomici, che utilizza atomi
 di alluminio, e che è stato calcolato possa sbagliare di un secondo dopo
 addirittura 3.7 miliardi di anni 
\begin_inset CommandInset citation
LatexCommand cite
key "1"

\end_inset

.
 Nella tecnologia informatica, e soprattutto nei database, la questione
 del tempo è sempre stata messa "in secondo piano", poichè si è sempre privilegi
ata la conservazione dei dati, piuttosto che la loro accuratezza temporale.
 In questo documento verrà trattata la questione dei database temporali,
 una tecnologia non nuova in campo informatico, che rimane tuttora poco
 conosciuta ai più, ma largamente usata nelle applicazioni reali.
 Verrà prima di tutto presentata la tecnologia come è stata teorizzata alle
 origini e alcuni concetti basilari, in seguito verranno presentati alcuni
 esempi di applicazione in SQL-92 e verranno trattate le nuove funzionalità
 temporali presenti nella versione 2011 dello standard SQL.
 I database temporali verranno inoltre trattati sotto un diverso punto di
 vista, cioè quello dei database cosiddetti NoSQL, che con la loro diversa
 filosofia hanno bisogno di un approccio differente.
 Infine, ma non meno importante, verrà presentato un caso concreto di utilizzo
 dei database temporali, ovvero la Fondazione Bruno Kessler, che li utilizza
 in maniera proficua ed efficiente.
\end_layout

\begin_layout Abstract
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Introduzione
\end_layout

\begin_layout Section
Il concetto del tempo
\end_layout

\begin_layout Standard
Riflettendo un attimo su una giornata qualsiasi della nostra vita, è facile
 accorgersi come l'esistenza di ognuno sia scandita, in maniera continua
 e regolare, da un'entità quasi astratta, ma che con il passare degli anni
 e delle epoche, e con l'innovazione tecnologica, ha acquistato sempre più
 valore e significato: il tempo.
 Ormai non ci si fa quasi più caso, ma non facciamo altro che rincorrere,
 in maniera sempre più frenetica, il tempo passato: abbiamo degli orari
 per entrare al lavoro, altri ancora per uscire, altri orari "tradizionali"
 dedicati ai pasti o al tempo libero, e così via.
 
\end_layout

\begin_layout Standard
Anche nell'informatica, forse più che in altri ambiti, il tempo è fondamentale:
 basti pensare alla grande quantità di applicativi che vengono utilizzati
 nei più disparati contesti, dalle banche ai negozi, dalle centrali elettriche
 alle automobili, che hanno nelle variazioni temporali un fattore vitale
 del loro funzionamento.
 Per fare un esempio, nel caso di una banca, è necessario registrare le
 operazioni compiute fino ai decimi di secondo, o anche oltre, poichè una
 variazione minima, soprattutto nell'ambito del trading o della compravendita
 di titoli e azioni, potrebbe comportare una perdita di denaro anche piuttosto
 considerevole.
 
\end_layout

\begin_layout Standard
Tutti questi movimenti e transazioni devono naturalmente essere memorizzati
 da qualche parte, ed è qui che entra in gioco quella che è universalmente
 riconosciuta come la parte più iportante di ogni sistema software: il database.
 Sembra incredibile, ma al giorno d'oggi non tutti coloro che lavorano nel
 campo dell'informatica e dei software si rendono conto dell'importanza
 che ha una adeguata pianificazione dei database sotto l'aspetto temporale,
 anzi: molto spesso tale aspetto viene dimenticato, volutamente o meno,
 proprio perchè è considerato poco importante, e di conseguenza ha una priorità
 piuttosto bassa.
 
\end_layout

\begin_layout Standard
Generalmente, tutte queste vicissitudini riguardo l'organizzazione della
 struttura dati seguono un andamento abbastanza simile: all'inizio lo sviluppo
 del sistema procede senza particolari problemi, fino al punto in cui, a
 causa del rapido incremento del numero dei record (e molto spesso delle
 dimensioni del sistema software) è necessario modificare la struttura del
 database, per distinguere ad esempio tra record validi allo stato attuale,
 record non più validi e record con validità futura.
 Solitamente, quando si arriva a questo punto, è necessario mettere mano
 anche al codice del software, causando disagi considerevoli in materia
 di costi e di tempo impiegato per la risoluzione.
 Se poi l'azienda produttrice del software ha dimensioni molto grandi, magari
 con gruppi indipendenti che lavorano su parti diverse del prodotto, è facile
 immaginare come un intoppo apparentemente di rapida soluzione si possa
 trasformare in un problema di dimensioni enormi, così come i relativi oneri.
 È necessario quindi adottare fin da subito un approccio "temporale" nella
 creazione dei database, in modo da dedicare magari qualche ora in più nella
 redazione dello schema della base di dati, ma evitando disagi ben più consisten
ti nel futuro, sia a medio che lungo termine.
\end_layout

\begin_layout Part
Database temporali: Panoramica
\end_layout

\begin_layout Section
Storia e stato dell'arte
\end_layout

\begin_layout Standard
La storia dei database temporali inizia con un paradosso: i database convenziona
li, che memorizzano solo stringhe e numeri senza considerare il tempo, non
 sono completamente realistici.
 Infatti, i database di questo tipo rappresentano uno stato del sistema,
 ma non si sa precisamente quale.
 Le modifiche vengono attuate in un modo che si può dire distruttivo: i
 dati che hanno bisogno di un aggiornamento vengono semplicemente modificati,
 mentre quelli non più validi vengono cancellati, rendendo impossibile determina
re lo storico del database stesso.
 Da qui, sono nate molteplici necessità, come quella di tracciare un determinato
 evento dall'inizio alla fine, oppure similarmente tracciare oggetti e le
 relazioni che li accomunano.
 Proprio questi problemi hanno spinto Jacob Ben-Zvi (1982) e James Clifford
 (1983), indipendentemente l'uno dall'altro, a teorizzare una soluzione
 che potesse risolverli.
 Ben-Zvi, soprattutto, ideò per primo i concetti di tempo effettivo e di
 tempo di registrazione (che verranno successivamente rinominati in tempo
 di validità e tempo di transazione).
 Qualche anno più tardi Richard T.
 Snodgrass, professore universitario considerato oggi tra i più importanti
 esponenti dei database temporali, introdusse la sua versiona temporale
 del linguaggio QUEL (un precursore dell'attuale SQL), chiamata TQUEL.
 All'inizio degli anni '90, quando SQL ha preso piede in tutti i maggiori
 DBMS, soppiantando QUEL, Snodgrass ha continuato la sua opera pionieristica
 nel settore temporale dei database, creando prima una estensione di SQL-92
 stesso, nota come TSQL (da non confondere con T-SQL, o Transact-SQL, una
 estensione proprietaria di SQL di Microsoft), e successivamente ha posto
 le basi per la nuova versione dello standard, nota come SQL3, che ha incluso
 direttamente nello standard i primi concetti temporali.
 Nell'ultima versione di SQL, SQL-2011, si è chiuso il cerchio, completando
 il processo di implementazione delle ultime caratteristiche temporali mancanti.
\end_layout

\begin_layout Section
Gli elementi basilari
\end_layout

\begin_layout Standard
È prassi comune credere che un database temporale sia semplicemente "un
 database normale, con l'aggiunta di campi di data".
 In realtà, un database temporale è qualcosa di più di un semplice campo
 aggiuntivo, e lo dimostra il fatto che si basa su tre aspetti fondamentali,
 che nei database "classici" non sono presenti:
\end_layout

\begin_layout Itemize

\shape italic
Dati temporali
\end_layout

\begin_layout Itemize

\shape italic
Tempi
\end_layout

\begin_layout Itemize

\shape italic
Tipi di interrogazioni
\end_layout

\begin_layout Standard
Ognuna di queste categorie si divide in ulteriori tre elementi, per un totale
 di nove entità che sono fondamentali per lo studio dei database temporali.
\end_layout

\begin_layout Subsection
I dati temporali
\end_layout

\begin_layout Standard
I dati temporali rappresentano delle "quantità" di tempo, più o meno precise
 a seconda del tipo, che hanno un significato molto vicino a quello utilizzato
 in ambito comune.
 Nello specifico, si dividono in:
\end_layout

\begin_layout Itemize

\shape italic
Istanti
\shape default
, che come nel linguaggio comune rappresentano un momento preciso del tempo
 (come ad esempio il 19 luglio 2014, 22.36.20, oppure il largamente utilizzato
 
\family typewriter
NOW()
\family default
);
\end_layout

\begin_layout Itemize

\shape italic
Intervalli
\shape default
, anche questi vicini all'interpretazione comune, che non sono altro che
 una durata fissa (ad esempio, 3 mesi oppure 5 giorni);
\end_layout

\begin_layout Itemize

\shape italic
Periodi, 
\shape default
simili agli intervalli, con la caratteristica di avere un inizio e una fine
 ben precisi (ad esempio, dal 15 luglio 2014 al 30 settembre 2014);
\end_layout

\begin_layout Subsubsection
Istanti
\end_layout

\begin_layout Subsubsection
Intervalli
\end_layout

\begin_layout Subsubsection
Periodi
\end_layout

\begin_layout Subsection
I tempi
\end_layout

\begin_layout Standard
La categoria dei tempi, invece, comprende tre tipi di tempo che possono
 essere presenti in una tabella, e che hanno funzioni diverse a seconda
 del loro gruppo di appartenenza.
 Nello specifico si parla di:
\end_layout

\begin_layout Itemize

\shape italic
User-defined time
\shape default
, dove il tempo è inserito dall'utente e non ha alcun significato ai fini
 della validità dei dati;
\end_layout

\begin_layout Itemize

\shape italic
Tempo di validità
\shape default
, oppure definibile come periodo (avendo esso sia una data precisa di inizio
 che una data precisa di fine) all'interno di cui il dato è considerabile
 come valido.
\end_layout

\begin_layout Itemize

\shape italic
Tempo di transazione
\shape default
, cioè, in genere, l'istante nel quale il record relativo è stato inserito
 all'interno del database.
\end_layout

\begin_layout Standard
Questi concetti hanno senso e utilità pratica solo se sono considerati nel
 contesto di una tabella, che ne può contenere solo uno, due, oppure tutti
 e tre, con varie combinazioni adatte a diverse implementazioni, che saranno
 esaminate nella prossima sezione.
\end_layout

\begin_layout Subsection
Le interrogazioni
\end_layout

\begin_layout Standard
Per quanto riguarda i tipi di interrogazioni, infine, anche qui sono presenti
 tre diversi rami, riassumibili nel seguente modo:
\end_layout

\begin_layout Itemize

\shape italic
Corrente
\shape default
, cioè relativo all'istante attuale;
\end_layout

\begin_layout Itemize

\shape italic
Sequenziale
\shape default
, cioè relativo ad ogni istante di tempo
\end_layout

\begin_layout Itemize

\shape italic
Non-Sequenziale
\shape default
, cioè che esula dal tempo, ignorandolo completamente.
\end_layout

\begin_layout Subsubsection
Interrogazioni non temporali
\end_layout

\begin_layout Subsubsection
Interrogazioni correnti
\end_layout

\begin_layout Subsubsection
Interrogazioni sequenziali
\end_layout

\begin_layout Subsubsection
Interrogazioni non sequenziali
\end_layout

\begin_layout Subsection
Implementazione in SQL standard
\end_layout

\begin_layout Standard
Degli aspetti evidenziati, definire cosa è implementato in SQL, e soprattutto
 in che modo, non è cosa banale, soprattutto perchè gli applicativi che
 si basano interamente su SQL standard sono diventati ormai molto pochi.
 I maggiori DBMS (PostgreSQL, SQL Server, e Oracle su tutti) hanno da tempo
 optato per lo sviluppo di una versione estesa e personalizzata di SQL,
 in modo da non essere legati alle release, dilazionate negli anni, dello
 standard ufficiale, e per avere più libertà nell'inserire feature specifiche
 dei propri prodotti.
 Se per SQL intendiamo la versione standard, allora una copertura delle
 funzionalità temporali, seppur blanda e per certi aspetti lacunosa, si
 ha fin dalla versione del 1992, che poi si è evoluta nel corso degli anni
 fino ad arrivare all'ultima versione, nel 2011.
 Nello specifico, nel 1992 sono stati introdotti i tipi basilari per lo
 sviluppo delle carateristiche sopra elencate, come 
\family typewriter
DATE
\family default
, 
\family typewriter
TIME
\family default
, 
\family typewriter
TIMESTAMP
\family default
 e 
\family typewriter
INTERVAL
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "2"

\end_inset

.
 Nelle ultime release, soprattutto nella più recente, è stato aggiunto il
 costrutto 
\family typewriter
PERIOD
\family default
 (anche se in una accezione particolare, come si vedrà in seguito), e sono
 stati apportati notevoli miglioramenti all'intera gestione delle funzionalità
 temporali.
 Dal punto di vista dello standard, si può dire che i database temporali
 sono giunti a compimento solo nel 2011 
\begin_inset CommandInset citation
LatexCommand cite
key "3"

\end_inset

, dopo una fase di teorizzazione che ha visto i suoi inizi nel 1982, all'interno
 di programmi proprietari, e quindi durata quasi 30 anni.
\end_layout

\begin_layout Section
I costrutti fondamentali
\end_layout

\begin_layout Subsection
Tabelle
\end_layout

\begin_layout Standard
Le tabelle temporali non hanno necessariamente una struttura ben definita,
 infatti possono essere costruite in vari modi, utilizzando varie combinazioni
 dei tempi e dei tipi di dato temporale precedentemente trattati.
 Escludendo le tabelle contenenti solo categorie e valori di tempo definiti
 dall'utente, che non avendo significato ai fini della validità dei dati
 possono essere considerate come un qualsiasi altro campo, esistono anche
 qui tre tipi di strutture dati:
\end_layout

\begin_layout Itemize

\shape italic
Tabelle con tempo di validità
\shape default
, che salvano i dati sulla base del periodo o dell'intervallo di tempo in
 cui gli stessi sono validi;
\end_layout

\begin_layout Itemize

\shape italic
Tabelle con tempo di transazione
\shape default
, che salvano i dati sulla base dell'istante dell'inserimento, e rendono
 quindi possibile l'interrogazione dei dati per capire quando gli stessi
 si consideravano validi
\end_layout

\begin_layout Itemize

\shape italic
Tabelle bitemporali
\shape default
, che sono una variante di struttura dati che prevede la presenza sia del
 tempo di validità, che del tempo di transazione, fornendo quindi la maggiore
 completezza possibile per lo studio della validità dei dati contenuta in
 essi.
\end_layout

\begin_layout Standard
Di seguito sono presenti alcuni semplici esempi che sono utili per capire
 meglio come le varie tabelle possono essere utili ai fini della loro interrogaz
ione.
 Quando sarà necessario parlare di codice SQL, saranno presentate interrogazioni
 svolte con il codice della versione del 1992, a cui sarà affiancato, quando
 opportuno, quello della versione 2011, in modo da poter apprezzare le differenz
e e i miglioramenti nel corso degli anni.
\end_layout

\begin_layout Subsubsection
Tabelle con tempo di validità
\end_layout

\begin_layout Standard
Le tabelle con tempo di validità, come accennato sopra, sono delle particolari
 tabelle che presentano, oltre ai classici dati da memorizzare, anche una
 coppia di campi che hanno il compito di memorizzare l'intervallo in cui
 tali dati sono, o erano, validi.
 Il modo per utilizzare questi due campi è molteplice: si può salvare l'istante
 iniziale di validità e l'istante finale, oppure l'istante iniziale e l'interval
lo di validità, o ancora l'intervallo di validità e l'istante finale.
 Non esiste un modo migliore, poichè tutti e tre i criteri di rappresentazione
 conducono allo stesso risultato.
 
\end_layout

\begin_layout Standard
Un esempio chiaro di come possono essere utilizzate le tabelle con tempo
 di validità può essere trovato nel salvataggio della residenza di un soggetto.
 Per semplicità, supponiamo che tutte le variazioni del luogo di residenza,
 invece che ai Comuni, siano in capo a un ente superiore, che si occupa
 anche di mantenere il database che le contiene.
 Inoltre, limitiamo la tabella a due sole persone.
\end_layout

\begin_layout Standard
Senza tempo di validità, la tabella 
\family typewriter
RESIDENZA 
\family default
si presenta come segue: 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\backslash
makebox[
\backslash
textwidth]{%
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
